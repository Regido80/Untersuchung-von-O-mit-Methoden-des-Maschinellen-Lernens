# **Erzeugen aller Origamis der Länge l \in \N**
- mit Verwendung von Zykeltypen für die horizontale Verklebung
- mit Aussortieren nichtzusammenhängender Origamis

import numpy as np

Länge der betrachteten Origamis

l = 6

## Erzeuge alle Permutationen der Länge l, l/in /N

from itertools import permutations

SY = list(permutations(range(1, l+1)))

print("SY =", SY)

##Übersetzen von Standarddarstellung in Zykeldarstellung

k = 0

ZY = []

for k in range(0, len(SY)):

  ZYk = []

  s = 0         #Zykellistennr.
  i = 0         #Anz. erfasster Elemente von {1, ..., l}
  j = 0         #Zykellisten Position


  while i+1 < l+1:

    S = set(range(1, l+1))

    if s > 0:

      for m in range(0, s):

        S = S.difference(set(ZYk[m]))
        m = m+1

    r = min(S)

    zy = []
    zy.append(r)

    a = zy[0]

    while SY[k][a-1] != r:

      zy.append(SY[k][a-1])
      j = j+1
      a = zy[j]

    ZYk.append(zy)
  
    s = s+1
    i = i+j+1
    j = 0   

  ZY.append(ZYk)

  k = k+1

print("\nZY =", ZY)

##Erzeuge alle Zykeltypen der Länge l, l \in \N

from copy import deepcopy
 
# l:                  Länge des Zykeltyps (l /in /N)
# m:                  Anzahl der Zykel    (m = 1,...,l)
# r:                  Listeneintragsnr. der Liste der Zykellängen eines Zykeltyps der Länge l mit m Zykeln (r = 1,...,P(l,m))
# L[m-1]:             Liste der Zykellängen der Zykeltypen der Länge l mit m Zykeln
# L[m-1][r-1]:        Liste der Zykellängen des r-ten (eines) Zykeltyps der Länge l mit m Zykeln
# L[m-1][r-1][i]:     Länge des i-ten Zykels

###Abbruchkriterium

#t:                   Laufnr. (t = 1,...,m-1)
 
def abbkrit(t):                           #t = m - i

  Lsum = 0                     
 
  if m-t-1 > 0:
    for i in range(0, (m-t-1)):
      Lsum = Lsum + L[m-1][r-1][i]        #Lsum = L[0]+ ... + L[m-2-t]
 
  a = 0
 
  if (l - Lsum) % (t+1) < 1:              #Rest bei Division      (t+1 = m-(m-t-1))
    a = (l - Lsum) // (t+1)               #Ganzzahlige Division   (t+1 = m-(m-t-1))
    R = 0
  else:
    a = (l - Lsum) // (t+1)               #Ganzzahlige Division   (t+1 = m-(m-t-1))
    a = a+1
    R = (a * (t+1)) - (l-Lsum)
 
  A = []
 
  for s in range(0, t+1):                 #range((m-1-t), m-1+1):               Die Funktion range(0, n) zählt von 0 bis n-1!!!!!!!!!!!!!
    if s <= R-1:                          #Python zählt beginnend mit der Null!
      A.append(a-1)                       #A[s] = a-1
      s += 1
    else:
      A.append(a)                         #A[s] = a
      s += 1 

  Ltest = []
  
  for s in range((m-1-t), m-1+1):         #range(0, t+1):
    Ltest.append(L[m-1][r-1][s])                                                #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  if Ltest == A:                                                               
    return True
  else:
    return False  

###Progression

def progr(t):                                                                   #t = 1,...,n-1  , Laufnr.
  L[m-1][r-1][m-1-t] += 1

  if t > 1:
    for s in range(1, t):
      L[m-1][r-1][m-1-t+s] = L[m-1][r-1][m-1-t]
      
  L[m-1][r-1][m-1] = l - sum(L[m-1][r-1], -L[m-1][r-1][m-1])                    #sum(L[m-1][r-1], -L[m-1][r-1][m-1]) = L[m-1][r-1][0]+L[m-1][r-1][1]+...+L[m-1][r-1][m-2]

###Erzeuge Zykel in standardisierter Darst nach vorgabe von L[l-1][m-1][r-1]

#L[m-1][r-1] = [l_1, l_2, ...,l_m],          #l_i: Länge des i-ten Zykels
 
ZX = []                                      #ZX: Liste der Zykeltypen in Standarddarstellung
 
def zykel(l, m, r):
  
  ZX[m-1].append([])                         #ZX = [ [..] ,[..], ..., [..], [ [] ] ]
  
  s = 1

  for i in range(0, m):
    ZX[m-1][r-1].append([])
    for j in range(0, L[m-1][r-1][i]):       #Die Funktion range(0, n) zählt von 0 bis n-1!!!!!!!!!!!!!          
      ZX[m-1][r-1][i].append(s)
      s = s+1      
      j = j+1
    j = 0
    i = i+1  

###Algorithmus

ZX = []                                   #ZX: Liste der Zykeltypen in Standarddarstellung
 
L = []                                    #Liste aller Zykeltypen der Länge l

r = 1                                     #r: Laufnr., konkrete Realisierung eines Zykeltyps

####Initialisierung m = 1

m = 1                                     #Initialisierung m = 1
                                          
L.append([])                              #L = [[]]   :
L[0].append([])                           #L = [[[]]] :
L[0][0].append(l)                         #L = [[[l]]]: Untertliste der Zykellängen des Zykeltyps der Länge l mit m = 0+1 Zykeln
 
ZX.append([])                             #m: ZX = [ [    ] ]
ZX[0].append([])                          #r: ZX = [ [ [] ] ]
s = 1
ZX[0][0].append([])                       #einzelner Zykel des Zykeltyps l, m, r
for j in range(0, L[m-1][r-1][0]):        #auffüllen der einzelnen Zykel des Zykeltyps l, m, r
  ZX[0][0][0].append(s)
  s += 1
  j += 1

r = 1

####Initialisierung m = 2

m = 2                                     #Initialisierung m = 2

L.append([])                              #Initialisierung m = 2

ZX.append([])                             #m: ZX = [ [ [1,2,3,4,5] ], [  ] ]

for u in range(0, (l // 2)):
  L[1].append([])  
  L[1][u].append(u+1)                                                           
  R = l - sum(L[m-1][u])                  #sum(L[m-1][0] = m-2)
  L[1][u].append(R)

  ZX[m-1].append([])                      #m: ZX = [ [ [1,2,3,4,5] ], [[]] ]

  r = u+1

  s = 1
  for i in range(0, m):
    ZX[m-1][r-1].append([])
    for j in range(0, L[m-1][r-1][i]):
      ZX[m-1][r-1][i].append(s)
      s += 1
      j += 1
    j = 0
    i += 1

r = 1

####Algorithmus m <= l-2

m = 3

while m <= l-2:                           #Initialisierung m >= 3

  r = 1

#####Initialisieren von L[m-1][0]

  L.append([])

  L[m-1].append([])                       #Initialisierung m >= 3

  for s in range(1, m):
    L[m-1][0].append(1)                                                         #append([1])!!!!!!!!!!!!!!!!!!!!!!!!!!
    s = s+1

  R = l - sum(L[m-1][0])                  #sum(L[m-1][0] = m-2)
  L[m-1][0].append(R)                                                           #append([R])!!!!!!!!!!!!!!!!!!!!!!!!!!

  ZX.append([])                           #ZX = [ [..] ,[..], ..., [..], [    ] ]
   
  zykel(l, m, r)

#####Algorithmus

  t = 1                                   #t: Laufnummer, Stufe des Abbruchkriteriums

  while t <= m-1:

    if abbkrit(t) == False:

      Lzs = deepcopy(L[m-1][r-1])
      L[m-1].append(Lzs)    

      r = r+1

      progr(t)
   
      zykel(l, m, r)

    else:

      t = t+1

  m = m+1

r = 1

####Initialisierung m = l-1

m = l-1                                   #Initialisierung m = l-1

L.append([])                              #Initialisierung m = l-1
L[m-1].append([])
for s in range(0, l-1-1):
    L[m-1][0].append(1)
R = l - sum(L[m-1][0])                    #sum(L[m-1][0] = m-2)
L[m-1][0].append(R)

ZX.append([])                             #ZX = [ [..] ,[..], ..., [..], [    ] ]

zykel(l, m, r)

r = 1

####Initialisierung m = l

m = l                                     #Initialisierung m = l
                                         
L.append([])                              #L = [ [[5]], ..., [] ]   :
L[m-1].append([])                         #L = [ [[5]], ..., [[]] ] :
for s in range(0, l):
    L[m-1][0].append(1)

ZX.append([])                             #ZX = [ [..] ,[..], ..., [..], [    ] ]                  
 
zykel(l, m, r)

#print("\nZX =", ZX)                      #Darstellung als Liste von Listen (m) von Listen (r)

###Reduzieren der Liste ZX (flatten list)

zx = []

for M in range(0, l):

  for R in range(0, len(ZX[M])):
    zx.append(ZX[M][R])

ZX = []

ZX = deepcopy(zx)

print("\nZX =", ZX)

##Übersetzen von Zykel in Standarddarstellung

SX = []

for i in range(0, len(ZX)):

  SX.append([])
  
  j = 0                                         #j:  Laufnr., Zykellistennr.
  k = 0                                         #k:  Laufnr., Position in Zykelliste
  
  for n in range(0, l):
  
    if k == len(ZX[i][j])-1:                    #n:  Länge von SX[i][j]
      SX[i].append(ZX[i][j][0])                 #Letzter Eintrag des Zykels wird auf ersten Eintrag des Zykels geschickt

      j = j+1
      k = 0
      n = n+1
    else:
      SX[i].append(ZX[i][j][k+1])               #i-ter Eintrag des Zykels wird auf (i+1)-ten Eintrag des Zykels abgebildet

      k = k+1
      n = n+1

print("\nSX =", SX)

##Erzeuge alle Origamis der Länge l, l /in /N

O = []

O_j = []

j = 0
s = 0
t = 0

for s in range(0, len(ZX)):
  for t in range(0, len(ZY)):
    O_j.append(ZX[s])
    O_j.append(SX[s])
    O_j.append(ZY[t])
    O_j.append(SY[t])
    O.append(O_j)

    O_j = []
    j = j+1
    t = t+1
  t = 0
  s = s+1

#print("\nO =", O)

print("\nlen(O) =", len(O))

print("\nZX =", ZX)
print("\nSX =", SX)
print("\nlen(SX) =", len(SX))
print("\nZY =", ZY)
print("\nSY =", SY)
print("\nlen(SY) =", len(SY))

##Informationen über die Liste O der Origamis

print("Informationen über die Liste O der Origamis der Länge l /in /N")

print("\nl =", l)

#print("\nO = ", O)  
 
M = len(O)
 
print("\nM = len(O) =", M)
 
m = 30

print("\nBeispiel:")
 
print("\nm = ", m)
 
print("\nO[", m, "] = ", O[m])
 
print("\nO[m][0]: Horiz Verkl, Zykeldarst:     \t      O[", m, "][0] =",      O[m][0])
 
print("\nO[m][1]: Horiz Verkl, Standarddarst:  \t      O[", m, "][1] =",      O[m][1])
 
print("\nO[m][2]: Vertik Verkl, Zykeldarst:    \t      O[", m, "][2] =",      O[m][2])
 
print("\nO[m][3]: Vertik Verkl, Standarddarst: \t      O[", m, "][3] =",      O[m][3])

print("\nHoriz. Verkl., Zykeldarst")
 
print("\nO[", m, "]             = ", O[m],            "\t\t",                    " : Darst des m-ten O in der Liste")
print("\nO[", m, "][0]          = ", O[m][0],         "\t\t\t\t\t\t\t\t\t",      " : Horiz Verkl, Zykeldarst")
print("\nO[", m, "][0][0]       = ", O[m][0][0],      "\t\t\t\t\t\t\t\t\t\t",    " : Darst einzelner Zykel, betrachteter Block")
print("\nO[", m, "][0][0][0][0] = ", O[m][0][0][0],   "\t\t\t\t\t\t\t\t\t\t\t",  " : Einzelner Blockeintrag")
 
print("\nsm = len(O[m][0]): Anzahl der horiz Blöcke (anz der Zykel der Zykeldarst der horiz Verkl)")
sm = len(O[m][0])
print("\n  s", m, " = len(O[", m, "][0]) =", sm)
 
print("\nVertik. Verkl., Zykeldarst")

print("\nO[", m, "]             = ", O[m],            "\t\t",                    " : Darst des m-ten O in der Liste")
print("\nO[", m, "][2]          = ", O[m][2],         "\t\t\t\t\t\t\t\t\t",      " : Vertik Verkl, Zykeldarst")
print("\nO[", m, "][2][0]       = ", O[m][2][0],      "\t\t\t\t\t\t\t\t\t\t",    " : Darst einzelner Zykel, betrachteter Block")
print("\nO[", m, "][2][0][0][0] = ", O[m][2][0][0],   "\t\t\t\t\t\t\t\t\t\t\t",  " : Einzelner Blockeintrag")

print("\ntm = len(O[m][2]): Anzahl der vertik Blöcke (anz der Zykel der Zykeldarst der vertik Verkl)")
tm = len(O[m][2])
print("\n  t", m, " = len(O[", m, "][2]) =", tm)
 

m = 0

##Aussortieren nichtzusammenhängender Origamis

Überprüfen ob die horizontalen Blöcke vertikal nur mit sich selbst verknüpft sind

###Test-Funktion

def vertik_verkl_test(K):

  global m
  global p

####Erzeuge Liste deren Einträge genau die Länge der betrachteten horiz Blöcke sind

  j = []                                    #j[]:     Liste, speichert Länge der betrachteten Blöcke/Zykel

  for h in range(0, sm-1):                  #sm:      Anzahl der horiz Blöcke (anz der Zykel der Zykeldarst der horiz Verkl)
    if K[h] == 0:                           #h:       Nr.des betrachteten Zykels
      break                                 #K[h]:    Liste, speichert betrachteten horitz Block              
    y = len(O[m][0] [ K[h] - 1 ] )
    j.append(y)

#  print("j =", j)

####Erzeuge Menge (menge) deren Elemente die Nummern der EHQ der betrachteten horiz Blöcke sind            
          
  menge = set()                             #menge:   Menge der EHQ Nummern in horiz Block

  for h in range(0, sm-1):
    if K[h] == 0:
      break
    menge_h = set(O[m][0] [ K[h] - 1 ] )
    menge = menge.union(menge_h)
 
#  print("menge =", menge)

####Erzeuge Menge (vertik_menge) deren Elemente die Nummern derjenigen EHQ sind mit denen die EHQ der betrachteten horiz Blöcke nach oben verklebt sind
 
  vertik_menge = set()                      #vertik_menge:  Menge der oberen (vertik) Nachbarn der EHQ des betrachteten horiz Blocks

  for h in range(0, sm-1):
    if K[h] == 0:
      break    
    for n in range(0, j[h]):                #n:       EHQ-Nr.des betrachteten horiz Blocks
      vertik_menge.add(  O[m][3]  [    O[m][0]  [ K[h] - 1 ]  [n]  - 1    ]   ) #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#  print("vertik_menge =", vertik_menge)
 
####Falls die betrachteten Blöcke vertikal nur mit sich selbst verklebt sind lösche das zugehörige O 
 
  if menge == vertik_menge:
    p = True
  else:
    p = False

  return p

###Algorithmus

import itertools

from itertools import combinations

M = len(O)
 
m = 0

while m < M:

  sm = len(O[m][0])                                 #sm:    Anzahl der Zykel in der horizontalen Verklebestruktur
  if sm == 1:
    m = m+1
  else:

    S = []
    for s in range(1, sm+1):
      S.append(s)                                   #S = [1, 2, ..., sm]

    T = []                                          #T:    Liste aller Kombinationen von l Elementen der Menge S
    for h in range(1, sm):
      for t in combinations(S, h):
        T.append(t)

    K = []                                          #K:     Blockliste, speichert betrachtete horiz. Zykel/Blöcke
    for k in range(0, sm):
      K.append(0)
      k = k+1

    p = False

    for j in range(0, len(T)):

      for i in range(0,len(T[j])):
        K[i] = T[j][i]
        vertik_verkl_test(K)

        if p == True:
          O.remove(O[m])
          break

      if p == True:
        break

    if p == True:
      M = len(O)
    else:
      m = m+1
      M = len(O)

print("\nlen(O) =", len(O))
#print("\nO =", O)
#print("\nO[0] =", O[0]) 

# **Erzeugen eines Pixelmuster für jedes Origami der Länge l /in /N**

Zur Übergabe an das Neuronale Netz

print("l =", l)

## Initiiere Pixelmatrix

#Initiiere Pixelmatrix

P =[]
for m in range(0, len(O)):
  P.append([])
  for I in range(0, 105):                               #P[m]    = [ [], [], ...,[] ]
    P[m].append([])                                     #P[m][I] = [ 0, 0, ..., 0 ]
    for J in range(0, 105):
      P[m][I].append(1)                                                         #!!!!!!!!!!

#  print("P[", m,"] =", P[m])

## Darstellung der horiz Verklebung

#print("l =", l)



##Initiiere Pixelmatrix
#
#P =[]
#for m in range(0, len(O)):
#  P.append([])
#  for I in range(0, 105):                               #P[m]    = [ [], [], ...,[] ]
#    P[m].append([])                                     #P[m][I] = [ 0, 0, ..., 0 ]
#    for J in range(0, 105):
#      P[m][I].append(0)
#
####  print("P[", m,"] =", P[m])



#Benötigte Variablen und Mengen

Set = set()
for r in range(0, l):
  Set.add(r+1)                                          #Set = { 1, 2, ..., l}
###print("Set =", Set)

M = set()                                               #Menge der bereits abgearbeiteten horizontalen Zykel
N = set()                                               #Menge der bereits abgearbeiteten vertikelen Zykel

Ms = []                                                 #Liste der aktuellen horizontalen Zykeleinträge
Nt = []                                                 #Liste der aktuellen vertikalen Zykeleinträge

AHZ = set()                                             #List die die Zykellistennummern der bereits abgearbeiteten horiz Zykel speichert
AVZ = set()                                             #List die die Zykellistennummern der bereits abgearbeiteten vertik Zykel speichert  

I = 52                                                  #horiz Koord in der Pixelmatrix
J = 52                                                  #vertik Koord in der Pixelmatrix

S = 0                                                   #s: Pos des aktuellen vertik Zykels in der Zykelliste
T = 0                                                   #t: Pos des aktuellen horiz Zykels in der Zykelliste

V = 1                                                   #V: Horitz Ansatzpkt - und Richtung
W = 1                                                   #W: Vertik Amsatzpkt - und Richtung

k = 0                                                   #k: 
h = 0                                                   #h:

p = True                                                #p:



#Funktionen


##Bestimme T (T: vertik Zykelnr des aktuellen vertik Zykels)

def best_T():

  global T
  global k
  global Ms
  global N
  global m
  global O
  global S                                                                      
  global AHZ                                                                    


  #Lösche N, falls N aber nicht M vollständig
  if N == Set:                                                                  
##   print("N = Set")
##   print("Lösche N")    
    N = set()

  #Wähle anderes, noch nicht abgearbeitetes S, falls k größer len(Ms)
  if k > len(Ms)-1:                                                                
##    print("k > len(MS)-1")
##    print("Wähle anderes S")
    for ii in range(0, len(O[m][0])):
      II = set()
      II.add(len(O[m][0])-1-ii)    
      if II.issubset(AHZ):
        ii = ii+1
      else:
##        print(II, "ist nicht Untermenge von", AHZ)
        S = len(O[m][0])-1-ii
        Ms = O[m][0][S]
        k = 0
##        print("S =", S)
##        print("Ms =", Ms)
        break

  a = 0

  SS = 0                                                                        

  while a == 0:
##    print("a = 0")
    for i in range(k, len(Ms)):
      C = set()
      C.add(Ms[len(Ms)-1-i])
      if set(C).issubset(N):
        i = i+1
      else:
##        print("Wähle nächstes a")
        a = Ms[len(Ms)-1-i]
        k = i                                               #k: Eintragnr des horiz Ansatzblocks (von hinten abgezählt)
        break

    #Wähle anderes, noch nicht abgearbeitetes S, falls a nicht bestimmt werden kann
    if a == 0:
##      print("Wähle anderes S")
      for ii in range(0, len(O[m][0])):
        II = set()
        II.add(len(O[m][0])-1-ii)    
        if II.issubset(AHZ):
          ii = ii+1
        else:
##          print(II, "is not subset", AHZ)
          S = len(O[m][0])-1-ii
          
          #Lösche N, falls neu gewähltes S gleich vorherigem S
          if SS == S:                                                           
##            print("S ändert sich nicht")
##            print("Lösche N:")
##            print("N = {}")                                                     
            N = set()
          
          SS = S                                                                
          Ms = O[m][0][S]
          k = 0
##          print("S =", S)
##          print("Ms =", Ms)
          break

  A = []
  for s in range(0, len(O[m][2])):                        #A = O[m][2] = ZY[m]: Zykeldarstellung der vertik Verklebung
    A.append(set())
    for i in range(0, len(O[m][2][s])):
      A[s].add(O[m][2][s][i])

  for t in range(0, len(O[m][2])):
    H = set()
    H.add(a)
    if H.issubset(A[t]):                                  #a /in A[t]
      T = t                                               #T: Zykelnr der vertik Erw in der vertik Zykelliste, Nr des aktuellen Zykels
      AVZ.add(T)                                          #!!!!!!!!!!!!!!!!!!!!                                 
    else:
      t = t+1

##Bestimme S (S: horiz Zykelnr des aktuellen horiz Zykels)

def best_S():

  global S, h, k, Nt, M, N, m, O, T, AVZ

  #Lösche N, falls N aber nichtM vollst
  if N == Set:                                                                  
    N = set()

  #Wähle anderes, noch nicht abgearbeitetes T, falls h größer len(Nt)
  if h > len(Nt)-1:                                                             
##    print("h > len(Nt)-1")
##    print("Wähle anderes T")
    for jj in range(0, len(O[m][2])):
      JJ = set()
      JJ.add(len(O[m][2])-1-jj)
      if JJ.issubset(AVZ):
        jj = jj+1
      else:
##        print(JJ, "ist nicht Untermenge von", AVZ)
        T = len(O[m][2])-1-jj
        Nt = O[m][2][T]
        h = 0
##        print("T =", T)
##        print("Nt =", Nt)
        break

  b = 0

  TT = 0

  while b == 0:
##    print("b = 0")
    for j in range(h, len(Nt)):
      D = set()
      D.add(Nt[len(Nt)-1-j])
      if D.issubset(M):
        j = j+1
      else:
##        print("Wähle nächstes b")
        b = Nt[len(Nt)-1-j]
        h = j                                             #h: Eintragnr des vertik Ansatzblocks (von hinten abgezählt)
        break

    JJJ = set()

    #Wähle anderes, noch nicht abgearbeitetes T, falls b nicht bestimmt werden kann
    if b == 0:
      print("Wähle anderes T")
      for jj in range(0, len(O[m][2])):
        JJ = set()
        JJ.add(len(O[m][2])-1-jj)
        JJJ.add(len(O[m][2])-1-jj)
        if JJ.issubset(AVZ):
          jj = jj+1
        else:
          T = len(O[m][2])-1-jj
          
          #wähle anderes, noch nicht abgearbeitetes S, falls neu gewähltes T gleich bisherigem T
          if TT == T:                                                           
##            print("T bleibt unverändert")
##            print("Wähle anderes S ")
##            print("Breche Funktion ab")
            for ii in range(0, len(O[m][0])):
              II = set()
              II.add(len(O[m][0])-1-ii)
              if II.issubset(AHZ):
                ii = ii+1
              else:
##                print(II, "is not subset", AHZ)
                S = len(O[m][0])-1-ii
                Ms = O[m][0][S]
                k = 0
##                print("S =", S)
##                print("Ms =", Ms)
                return                                                          

          TT = T
          Nt = O[m][2][T]
          h = 0
##          print("T =", T)
##          print("Nt =", Nt)
          break

      #Lösche AVZ, falls AVZ vollst
      if JJJ == AVZ:                                                                
        AVZ = set()    

  B = []
  for t in range(0, len(O[m][0])):                        #B = O[m][0] = ZX[m]: Zykeldarstellung der horiz Verklebevorschrift
    B.append(set())
    for j in range(0, len(O[m][0][t])):
      B[t].add(O[m][0][t][j])

  for s in range(0, len(O[m][0])):
    H = set()
    H.add(b)
    if H.issubset(B[s]):
      S = s                                               #S: Zykelnr der horiz Erw in der horiz Zykelliste, Nr des aktuellen Zykels
      AHZ.add(S)                                                                
    else:
      s = s+1


#Best Ansatzpkt des Erweiterungsblocks/der Blockerweiterung und Erweiterungsrichtung

##horiz Erw

def horiz_erw():
  global I, J, k, h, O, V, W, m, S, T
  x = O[m][2][T][len(O[m][2][T])-1-h]
  if x%2 == 0:                                            #x%2 == 0  <=>  x gerade
    if W == 1:                                            #Anschluß an nach oben gerichteten vertikalen Block      
      
      for ss in range(0, h*6+2):                                                
        if J-1 < 7:
          J = 97
        else:
          J = J-1
      
      I = I-2
    else:                                                 #Anschluß an nach unten gerichteten vertikalen Block
      
      for ss in range(0, h*6+2):                                                
        if J+1 > 97:
          J = 7
        else:
          J = J+1      

      I = I-2
    V = 0                                                 #Fortsetzung/Erweiterung nach links
#    print("Fortsetzung/Erweiterung nach LINKS")
  else:                                                   #x ungerade
    if W == 1:      
      
      for ss in range(0, h*6+2):                                                
        if J-1 < 7:
          J = 97
        else:
          J = J-1      
      
      I = I+2
    else:

      for ss in range(0, h*6+2):                                                
        if J+1 > 97:
          J = 7
        else:
          J = J+1
      
      I = I+2
    V = 1                                                 #Fortsetzung/Erweiterung nach rechts
#    print("Fortsetzung/Erweiterung nach RECHTS")

##vertik Erw

def vertik_erw():
  global I, J, k, h, O, W, V, m, T, S
  y = O[m][0][S][len(O[m][0][S])-1-k]
  if y%2 == 0:                                            #y%2 == 0  <=>  y gerade
    if V == 1:                                            #Anschluß an nach rechts gerichteten horizontalen Block
      for tt in range(0, k*6+2):
        if I-1 < 7:
          I = 97
        else:
          I = I-1
      J = J+2
    else:                                                 #Anschluß an nach links gerichteten horizontalen Block
      for tt in range(0, k*6+2):
        if I+1 > 97:
          I = 7
        else:
          I = I+1
      J = J+2
    W = 1                                                 #Fortsetzung/Erweiterung nach oben
#    print("Fortsetzung/Erweiterung nach OBEN")
  else:                                                   #y ungerade
    if V == 1:      
      for tt in range(0, k*6+2):
        if I-1 < 7:
          I = 97
        else:
          I = I-1
      J = J-2
    else:
      for tt in range(0, k*6+2):
        if I+1 > 97:
          I = 7
        else:
          I = I+1
      J = J-2
    W = 0                                                 #Fortsetzung/Erweiterung nach unten
#    print("Fortsetzung/Erweiterung nach UNTEN")


#Fortsetzen des Pixelmusters, Ansetzen weiterer Blöcke nach vorgabe

##horiz Block

def horiz_block():
  global I                                                #I: Horiz Koord
  global J                                                #J: Vertik koord
  global S, V, W, m, O, P, M, Ms

  Ms = []

  for t in range(0, len(O[m][0][S])):

    for u in range(0, 6):

      if I+V > 98:                                        #falls Block den Rand/Rahmen von 6 Pixeln Stärke erreicht
#        print("Block erreicht rechten Rand")
        I = 7
      if I-(1-V) < 6:
#        print("Block erreicht linken Rand")
        I = 97

      ii = 0                                                                    
      
      while P[m][I][J] != 1:                              #falls Blöcke sich kreuzen  #!!!!!!!!!!
##        print("P[m][I][J] =", P[m][I][J])
#        print("Blöcke kreuzen sich", ii)
        I = V*(I+1)+(1-V)*(I-1)
        if I > 97:
          I = 7
        if I < 7:
          I = 97
##       print("I =", I)
##        print("J =", J)
        ii = ii+1                                                               
        if ii > 105:
#          print("Sprung in vertikale Richtung")
          J = W*(J+6)+(1-W)*(J-6)                                               
          ii = 0                                                                

      for f in range(0, 3):
        P[m][I][J-1+f] = 0                                                      #1!!!!!!!!!!

      I = V*(I+1)+(1-V)*(I-1)                             #= I+V*1-(1-V)*1   
      
    M.add(O[m][0][S][t])
    Ms.append(O[m][0][S][t])

##vertik Block

def vertik_block():
  global I, J, T, W, V, m, O, N, Nt

  Nt = []

## print("len(O[m][2][T]) =", len(O[m][2][T]))

  for s in range(0, len(O[m][2][T])):
    for v in range(0, 6):
      if J+W > 98:
#        print("Block erreicht oberen Rand")
        J = 7
##        print("J =", J)
      if J-(1-W) < 6:
#        print("Block erreicht unteren Rand")
        J = 97
##        print("J =", J)
      jj = 0                                                                    
      while P[m][I][J] != 1:                                                    #!!!!!!!!!!
##       print("P[m][I][J] =", P[m][I][J])
#        print("Blöcke kreuzen sich", jj)
        J = W*(J+1)+(1-W)*(J-1)
        if J > 97:
          J = 7
        if J < 7:
          J = 97
##        print("I =", I)
##        print("J =", J)
        jj = jj+1                                                               
        if jj > 105:
#          print("Sprung in horizontale Richtung")
          I = V*(I+6)+(1-V)*(I-6)                                               
          jj = 0                                                                
##        print("J =", J)
      for f in range(0, 3):
        P[m][I-1+f][J] = 0                                                      #1!!!!!!!!!!
      J = W*(J+1)+(1-W)*(J-1)                             #J+W*1-(1-W)*1
##      print("J =", J)
  
    N.add(O[m][2][T][s])
    Nt.append(O[m][2][T][s])


#Überprüfe ob anzusetzender Zykelblock aus bisherigem Block herausführt

##vertik

def vertik_test():
  global T, p, Nt, M, k, II, JJ
  nt = set(Nt)
  if nt.issubset(M):
    p = True                                        #p = True: führt nicht heraus
    k = k+1                                                                     
  else:
    p = False                                       #p = True: führt heraus

##horiz

def horiz_test():
  global S, p, Ms, N, h, II, JJ
  ms = set(Ms)
  if ms.issubset(N):
    p = True                                        #p = True: führt nicht heraus
    h = h+1                                                                     
  else:
    p = False                                       #p = True: führt heraus



#Algorithmus

for m in range(0, len(O)):                          #(0, len(O)):

  M = set()                                         #Menge der bereits abgearbeiteten horizontalen Zykel
  N = set()                                         #Menge der bereits abgearbeiteten vertikelen Zykel

  AHZ = set()                                       #List die die Zykellistennummern der bereits abgearbeiteten horiz Zykel speichert
  AVZ = set()                                       #List die die Zykellistennummern der bereits abgearbeiteten vertik Zykel speichert

  I = 52                                            #horiz Koord in der Pixelmatrix
  J = 52                                            #vertik Koord in der Pixelmatrix

  II = 0
  JJ = 0

  S = 0                                             #s: Pos des aktuellen vertik Zykels in der Zykelliste
  T = 0                                             #t: Pos des aktuellen horiz Zykels in der Zykelliste

  V = 1                                             #V: Horitz Ansatzpkt und - Richtung
  W = 1                                             #W: Vertik Amsatzpkt und - Richtung

  k = 0                                             #k: 
  h = 0                                             #h:

  p = True                                          #p:

  print("\n\nO[", m, "] =", O[m])
#  print("O[", m, "][0] =", O[m][0])
#  print("O[", m, "][2] =", O[m][2])

#  print("\nAnfangskoord in der Pixelmatrix")
#  print("I =", I)
#  print("J =", J)

#  print("\nErzeuge horizontalen Anfangsblock")

  horiz_block()                                     #horiz Startblock nach Vorgabe des ersten horiz Zykels, liefert M, Ms

  AHZ.add(0)                                                                    

#  print("I =", I)
#  print("J =", J)
#  print("Ms =", Ms)
#  print("M =", M)

  if M == Set:
    print("Horiz Verklebung vollständig in Blöcken dargestellt")
#    print("continue")
    continue

  for g in range(1, 5*l):                           # l):

    II = I                                          #Rücksetz Pixelkoord falls p == True
    JJ = J                                          #Rücksetz Pixelkoord falls p == True

    if g%2 == 0:                                    #g gerade
#      print("\nHoriz Blockfortsetzung")
      while p == True:

#        print("Best h, S")
        best_S()                                    #liefert Ansatzblock, k, S
#        print("h =", h, "\t\t\th: Eintragnr des vertik Ansatzblocks (abgezählt von hinten)")
#        print("S =", S, "\t\t\tS: Pos des aktuellen vertik Zykels in der Zykelliste")
        
#        print("Best Fortsetzungsrichtung, Koord des Ansatzpixels")
        horiz_erw()                                 #liefert Fortsetzungsrichtung, Pixelkoord
#        print("I =", I)
#        print("J =", J)
        
#        print("Erzeuge horiz Blockfortsetzung, best Ms")
        horiz_block()                               #erzeugt Blockfortsetzung
#        print("len(O[m][0][S]) =", len(O[m][0][S])) 
#        print("I =", I)
#        print("J =", J)
#        print("Ms =", Ms)
#        print("M =", M)
        
#        print("Test")
        horiz_test()                                #überprüft ob Zykel zum angesetzten Block aus bisherigem Block herausführt
#        print("p =", p)
#        print("h =", h)
        if p == True:                                                           
          I = II
          J = JJ
#        print("I =", I)
#        print("J =", J)

        if M == Set:
          break

      p = True
      h = 0

    else:
#      print("\nVertik Blockfortsetzung")
      while p == True:

#        print("Best k, T")
        best_T()
#        print("k =", k, "\t\t\tk: Eintragnr des horiz Ansatzblocks (abgezählt von hinten)")
#        print("T =", T, "\t\t\tT: Pos des aktuellen horiz Zykels in der Zykelliste")

#        print("Best Fortsetzungsrichtung, Koord des Ansatzpixels")
        vertik_erw()
#        print("I =", I)
#        print("J =", J)

#        print("Erzeuge vertik Blockfortsetzung, best Nt")
        vertik_block()
#        print("len(O[m][2][T]) =", len(O[m][2][T]))
#        print("I =", I)
#        print("J =", J)
#        print("Nt =", Nt)
#        print("N =", N)

#        print("Test")
        vertik_test()
#        print("p =", p)
#        print("k =", k)
        if p == True:                                                           
          I = II
          J = JJ
#        print("I =", I)
#        print("J =", J)

        if M == Set:
          break

      p = True
      k = 0

###      print("P[", m, "] =")
###      for i in range(0, 105):
###        print(i, "\t", P[m][i])      

    if M == Set:
      break

  if M == Set:
    print("Horiz Verklebung vollständig in Blöcken dargestellt")
    continue

## Darstellung der vertik Verklebung

Aus obigem Code durch:

-Vertauschen der Permutation der horizontalen Verklebestruktur mit der Permutation der vertikalen Verklebestruktur

-Vertauschen der Ansetzrichtungen


#print("l =", l)



##Initiiere Pixelmatrix
#
#P =[]
#for m in range(0, len(O)):
#  P.append([])
#  for I in range(0, 105):                               #P[m]    = [ [], [], ...,[] ]
#    P[m].append([])                                     #P[m][I] = [ 0, 0, ..., 0 ]
#    for J in range(0, 105):
#      P[m][I].append(0)
#
####  print("P[", m,"] =", P[m])



#Benötigte Variablen und Mengen

Set = set()
for r in range(0, l):
  Set.add(r+1)                                          #Set = { 1, 2, ..., l}
###print("Set =", Set)

M = set()                                               #Menge der bereits abgearbeiteten horizontalen Zykel
N = set()                                               #Menge der bereits abgearbeiteten vertikelen Zykel

Ms = []                                                 #Liste der aktuellen horizontalen Zykeleinträge
Nt = []                                                 #Liste der aktuellen vertikalen Zykeleinträge

AHZ = set()                                             #List die die Zykellistennummern der bereits abgearbeiteten horiz Zykel speichert
AVZ = set()                                             #List die die Zykellistennummern der bereits abgearbeiteten vertik Zykel speichert  

I = 52                                                  #horiz Koord in der Pixelmatrix
J = 52                                                  #vertik Koord in der Pixelmatrix

S = 0                                                   #s: Pos des aktuellen vertik Zykels in der Zykelliste
T = 0                                                   #t: Pos des aktuellen horiz Zykels in der Zykelliste

V = 1                                                   #V: Horitz Ansatzpkt - und Richtung
W = 1                                                   #W: Vertik Amsatzpkt - und Richtung

k = 0                                                   #k: 
h = 0                                                   #h:

p = True                                                #p:



#Funktionen


##Bestimme T (T: vertik Zykelnr des aktuellen vertik Zykels)

def best_T():

  global T
  global k
  global Ms
  global N
  global m
  global O
  global S                                                                      
  global AHZ                                                                    


  #Lösche N, falls N aber nicht M vollständig
  if N == Set:                                                                  
##   print("N = Set")
##   print("Lösche N")    
    N = set()

  #Wähle anderes, noch nicht abgearbeitetes S, falls k größer len(Ms)
  if k > len(Ms)-1:                                                                
##    print("k > len(MS)-1")
##    print("Wähle anderes S")
    for ii in range(0, len(O[m][2])):
      II = set()
      II.add(len(O[m][2])-1-ii)    
      if II.issubset(AHZ):
        ii = ii+1
      else:
##        print(II, "ist nicht Untermenge von", AHZ)
        S = len(O[m][2])-1-ii
        Ms = O[m][2][S]
        k = 0
##        print("S =", S)
##        print("Ms =", Ms)
        break

  a = 0

  SS = 0                                                                        

  while a == 0:
##    print("a = 0")
    for i in range(k, len(Ms)):
      C = set()
      C.add(Ms[len(Ms)-1-i])
      if set(C).issubset(N):
        i = i+1
      else:
##        print("Wähle nächstes a")
        a = Ms[len(Ms)-1-i]
        k = i                                               #k: Eintragnr des horiz Ansatzblocks (von hinten abgezählt)
        break

    #Wähle anderes, noch nicht abgearbeitetes S, falls a nicht bestimmt werden kann
    if a == 0:
##      print("Wähle anderes S")
      for ii in range(0, len(O[m][2])):
        II = set()
        II.add(len(O[m][2])-1-ii)    
        if II.issubset(AHZ):
          ii = ii+1
        else:
##          print(II, "is not subset", AHZ)
          S = len(O[m][2])-1-ii
          
          #Lösche N, falls neu gewähltes S gleich vorherigem S
          if SS == S:                                                           
##            print("S ändert sich nicht")
##            print("Lösche N:")
##            print("N = {}")                                                     
            N = set()
          
          SS = S                                                                
          Ms = O[m][2][S]
          k = 0
##          print("S =", S)
##          print("Ms =", Ms)
          break

  A = []
  for s in range(0, len(O[m][0])):                        #A = O[m][0] = ZY[m]: Zykeldarstellung vertauscht
    A.append(set())
    for i in range(0, len(O[m][0][s])):
      A[s].add(O[m][0][s][i])

  for t in range(0, len(O[m][0])):
    H = set()
    H.add(a)
    if H.issubset(A[t]):                                  #a /in A[t]
      T = t                                               #T: Zykelnr der vertik Erw in der vertik Zykelliste, Nr des aktuellen Zykels
      AVZ.add(T)                                          #!!!!!!!!!!!!!!!!!!!!                                 
    else:
      t = t+1

##Bestimme S (S: horiz Zykelnr des aktuellen horiz Zykels)

def best_S():

  global S, h, k, Nt, M, N, m, O, T, AVZ

  #Lösche N, falls N aber nichtM vollst
  if N == Set:                                                                  
    N = set()

  #Wähle anderes, noch nicht abgearbeitetes T, falls h größer len(Nt)
  if h > len(Nt)-1:                                                             
##    print("h > len(Nt)-1")
##    print("Wähle anderes T")
    for jj in range(0, len(O[m][0])):
      JJ = set()
      JJ.add(len(O[m][0])-1-jj)
      if JJ.issubset(AVZ):
        jj = jj+1
      else:
##        print(JJ, "ist nicht Untermenge von", AVZ)
        T = len(O[m][0])-1-jj
        Nt = O[m][0][T]
        h = 0
##        print("T =", T)
##        print("Nt =", Nt)
        break

  b = 0

  TT = 0

  while b == 0:
##    print("b = 0")
    for j in range(h, len(Nt)):
      D = set()
      D.add(Nt[len(Nt)-1-j])
      if D.issubset(M):
        j = j+1
      else:
##        print("Wähle nächstes b")
        b = Nt[len(Nt)-1-j]
        h = j                                             #h: Eintragnr des vertik Ansatzblocks (von hinten abgezählt)
        break

    JJJ = set()

    #Wähle anderes, noch nicht abgearbeitetes T, falls b nicht bestimmt werden kann
    if b == 0:
      print("Wähle anderes T")
      for jj in range(0, len(O[m][0])):
        JJ = set()
        JJ.add(len(O[m][0])-1-jj)
        JJJ.add(len(O[m][0])-1-jj)
        if JJ.issubset(AVZ):
          jj = jj+1
        else:
          T = len(O[m][0])-1-jj
          
          #wähle anderes, noch nicht abgearbeitetes S, falls neu gewähltes T gleich bisherigem T
          if TT == T:                                                           
##            print("T bleibt unverändert")
##            print("Wähle anderes S ")
##            print("Breche Funktion ab")
            for ii in range(0, len(O[m][2])):
              II = set()
              II.add(len(O[m][2])-1-ii)
              if II.issubset(AHZ):
                ii = ii+1
              else:
##                print(II, "is not subset", AHZ)
                S = len(O[m][2])-1-ii
                Ms = O[m][2][S]
                k = 0
##                print("S =", S)
##                print("Ms =", Ms)
                return                                                          

          TT = T
          Nt = O[m][0][T]
          h = 0
##          print("T =", T)
##          print("Nt =", Nt)
          break

      #Lösche AVZ, falls AVZ vollst
      if JJJ == AVZ:                                                                
        AVZ = set()    

  B = []
  for t in range(0, len(O[m][2])):                        #B = O[m][2] = ZY[m]: Zykeldarstellung vertauscht
    B.append(set())
    for j in range(0, len(O[m][2][t])):
      B[t].add(O[m][2][t][j])

  for s in range(0, len(O[m][2])):
    H = set()
    H.add(b)
    if H.issubset(B[s]):
      S = s                                               #S: Zykelnr der horiz Erw in der horiz Zykelliste, Nr des aktuellen Zykels
      AHZ.add(S)                                                                
    else:
      s = s+1


#Best Ansatzpkt des Erweiterungsblocks/der Blockerweiterung und Erweiterungsrichtung

##horiz Erw

def horiz_erw():
  global I, J, k, h, O, V, W, m, S, T
  x = O[m][0][T][len(O[m][0][T])-1-h]
  if x%2 == 1:                                            #x ungerade
    if W == 0:                                            #Anschluß an nach oben gerichteten vertikalen Block      
      
      for ss in range(0, h*6+2):                                                
        if J-1 < 7:
          J = 97
        else:
          J = J-1
      
      I = I+2
    else:                                                 #Anschluß an nach unten gerichteten vertikalen Block
      
      for ss in range(0, h*6+2):                                                
        if J+1 > 97:
          J = 7
        else:
          J = J+1      

      I = I+2
    V = 0                                                 #Fortsetzung/Erweiterung nach rechts
#    print("Fortsetzung/Erweiterung nach RECHTS")
  else:                                                   #x gerade
    if W == 0:      
      
      for ss in range(0, h*6+2):                                                
        if J-1 < 7:
          J = 97
        else:
          J = J-1      
      
      I = I-2
    else:

      for ss in range(0, h*6+2):                                                
        if J+1 > 97:
          J = 7
        else:
          J = J+1
      
      I = I-2
    V = 1                                                 #Fortsetzung/Erweiterung nach links
#    print("Fortsetzung/Erweiterung nach LINKS")

##vertik Erw

def vertik_erw():
  global I, J, k, h, O, W, V, m, T, S
  y = O[m][2][S][len(O[m][2][S])-1-k]
  if y%2 == 1:                                            #y ungerade
    if V == 0:                                            #Anschluß an nach rechts gerichteten horizontalen Block
      for tt in range(0, k*6+2):
        if I-1 < 7:
          I = 97
        else:
          I = I-1
      J = J-2
    else:                                                 #Anschluß an nach links gerichteten horizontalen Block
      for tt in range(0, k*6+2):
        if I+1 > 97:
          I = 7
        else:
          I = I+1
      J = J-2
    W = 1                                                 #Fortsetzung/Erweiterung nach unten
#    print("Fortsetzung/Erweiterung nach UNTEN")
  else:                                                   #y gerade
    if V == 0:      
      for tt in range(0, k*6+2):
        if I-1 < 7:
          I = 97
        else:
          I = I-1
      J = J+2
    else:
      for tt in range(0, k*6+2):
        if I+1 > 97:
          I = 7
        else:
          I = I+1
      J = J+2
    W = 0                                                 #Fortsetzung/Erweiterung nach oben
#    print("Fortsetzung/Erweiterung nach OBEN")


#Fortsetzen des Pixelmusters, Ansetzen weiterer Blöcke nach vorgabe

##horiz Block

def horiz_block():
  global I                                                #I: Horiz Koord
  global J                                                #J: Vertik koord
  global S, V, W, m, O, P, M, Ms

  V = 1-V
  W = 1-W

  Ms = []

  for t in range(0, len(O[m][2][S])):

    for u in range(0, 6):

      if I+V > 98:                                        #falls Block den Rand/Rahmen von 6 Pixeln Stärke erreicht
#        print("Block erreicht rechten Rand")
        I = 7
      if I-(1-V) < 6:
#        print("Block erreicht linken Rand")
        I = 97

      ii = 0                                                                    
      
      while P[m][I][J] != 1:                              #falls Blöcke sich kreuzen  #!!!!!!!!!!
##        print("P[m][I][J] =", P[m][I][J])
#        print("Blöcke kreuzen sich", ii)
        I = V*(I+1)+(1-V)*(I-1)
        if I > 97:
          I = 7
        if I < 7:
          I = 97
##       print("I =", I)
##        print("J =", J)
        ii = ii+1                                                               
        if ii > 105:
#          print("Sprung in vertikale Richtung")
          J = W*(J+6)+(1-W)*(J-6)                                               
          ii = 0                                                                

      for f in range(0, 3):
        P[m][I][J-1+f] = 0                                                      #1!!!!!!!!!!

      I = V*(I+1)+(1-V)*(I-1)                             #= I+V*1-(1-V)*1   
      
    M.add(O[m][2][S][t])
    Ms.append(O[m][2][S][t])

  V = 1-V
  W = 1-W

##vertik Block

def vertik_block():
  global I, J, T, W, V, m, O, N, Nt

  V = 1-V
  W = 1-W

  Nt = []

## print("len(O[m][0][T]) =", len(O[m][0][T]))

  for s in range(0, len(O[m][0][T])):
    for v in range(0, 6):
      if J+W > 98:
#        print("Block erreicht oberen Rand")
        J = 7
##        print("J =", J)
      if J-(1-W) < 6:
#        print("Block erreicht unteren Rand")
        J = 97
##        print("J =", J)
      jj = 0                                                                    
      while P[m][I][J] != 1:                                                    #!!!!!!!!!!
##       print("P[m][I][J] =", P[m][I][J])
#        print("Blöcke kreuzen sich", jj)
        J = W*(J+1)+(1-W)*(J-1)
        if J > 97:
          J = 7
        if J < 7:
          J = 97
##        print("I =", I)
##        print("J =", J)
        jj = jj+1                                                               
        if jj > 105:
#          print("Sprung in horizontale Richtung")
          I = V*(I+6)+(1-V)*(I-6)                                               
          jj = 0                                                                
##        print("J =", J)
      for f in range(0, 3):
        P[m][I-1+f][J] = 0                                                      #1!!!!!!!!!!
      J = W*(J+1)+(1-W)*(J-1)                             #J+W*1-(1-W)*1
##      print("J =", J)
  
    N.add(O[m][0][T][s])
    Nt.append(O[m][0][T][s])

  V = 1-V
  W = 1-W


#Überprüfe ob anzusetzender Zykelblock aus bisherigem Block herausführt

##vertik

def vertik_test():
  global T, p, Nt, M, k, II, JJ
  nt = set(Nt)
  if nt.issubset(M):
    p = True                                        #p = True: führt nicht heraus
    k = k+1                                                                     
  else:
    p = False                                       #p = True: führt heraus

##horiz

def horiz_test():
  global S, p, Ms, N, h, II, JJ
  ms = set(Ms)
  if ms.issubset(N):
    p = True                                        #p = True: führt nicht heraus
    h = h+1                                                                     
  else:
    p = False                                       #p = True: führt heraus



#Algorithmus

for m in range(0, len(O)):                          #(0, len(O)):

  M = set()                                         #Menge der bereits abgearbeiteten horizontalen Zykel
  N = set()                                         #Menge der bereits abgearbeiteten vertikelen Zykel

  AHZ = set()                                       #List die die Zykellistennummern der bereits abgearbeiteten horiz Zykel speichert
  AVZ = set()                                       #List die die Zykellistennummern der bereits abgearbeiteten vertik Zykel speichert

  I = 52                                            #horiz Koord in der Pixelmatrix
  J = 52                                            #vertik Koord in der Pixelmatrix

  II = 0
  JJ = 0

  S = 0                                             #s: Pos des aktuellen vertik Zykels in der Zykelliste
  T = 0                                             #t: Pos des aktuellen horiz Zykels in der Zykelliste

  V = 1                                             #V: Horitz Ansatzpkt und - Richtung
  W = 1                                             #W: Vertik Amsatzpkt und - Richtung

  k = 0                                             #k: 
  h = 0                                             #h:

  p = True                                          #p:

  print("\n\nO[", m, "] =", O[m])
#  print("O[", m, "][0] =", O[m][0])
#  print("O[", m, "][2] =", O[m][2])

#  print("\nAnfangskoord in der Pixelmatrix")
#  print("I =", I)
#  print("J =", J)

#  print("\nErzeuge horizontalen Anfangsblock")

  horiz_block()                                     #horiz Startblock nach Vorgabe des ersten horiz Zykels, liefert M, Ms

  AHZ.add(0)                                                                    

#  print("I =", I)
#  print("J =", J)
#  print("Ms =", Ms)
#  print("M =", M)

  if M == Set:
    print("Vertik Verklebung vollständig in Blöcken dargestellt")
#    print("continue")
    continue

  for g in range(1, 5*l):                           # l):

    II = I                                          #Rücksetz Pixelkoord falls p == True
    JJ = J                                          #Rücksetz Pixelkoord falls p == True

    if g%2 == 0:                                    #g gerade
#      print("\nHoriz Blockfortsetzung")
      while p == True:

#        print("Best h, S")
        best_S()                                    #liefert Ansatzblock, k, S
#        print("h =", h, "\t\t\th: Eintragnr des vertik Ansatzblocks (abgezählt von hinten)")
#        print("S =", S, "\t\t\tS: Pos des aktuellen vertik Zykels in der Zykelliste")
        
#        print("Best Fortsetzungsrichtung, Koord des Ansatzpixels")
        horiz_erw()                                 #liefert Fortsetzungsrichtung, Pixelkoord
#        print("I =", I)
#        print("J =", J)
        
#        print("Erzeuge horiz Blockfortsetzung, best Ms")
        horiz_block()                               #erzeugt Blockfortsetzung
#        print("len(O[m][0][S]) =", len(O[m][0][S])) 
#        print("I =", I)
#        print("J =", J)
#        print("Ms =", Ms)
#        print("M =", M)
        
#        print("Test")
        horiz_test()                                #überprüft ob Zykel zum angesetzten Block aus bisherigem Block herausführt
#        print("p =", p)
#        print("h =", h)
        if p == True:                                                           
          I = II
          J = JJ
#        print("I =", I)
#        print("J =", J)

        if M == Set:
          break

      p = True
      h = 0

    else:
#      print("\nVertik Blockfortsetzung")
      while p == True:

#        print("Best k, T")
        best_T()
#        print("k =", k, "\t\t\tk: Eintragnr des horiz Ansatzblocks (abgezählt von hinten)")
#        print("T =", T, "\t\t\tT: Pos des aktuellen horiz Zykels in der Zykelliste")

#        print("Best Fortsetzungsrichtung, Koord des Ansatzpixels")
        vertik_erw()
#        print("I =", I)
#        print("J =", J)

#        print("Erzeuge vertik Blockfortsetzung, best Nt")
        vertik_block()
#        print("len(O[m][2][T]) =", len(O[m][2][T]))
#        print("I =", I)
#        print("J =", J)
#        print("Nt =", Nt)
#        print("N =", N)

#        print("Test")
        vertik_test()
#        print("p =", p)
#        print("k =", k)
        if p == True:                                                           
          I = II
          J = JJ
#        print("I =", I)
#        print("J =", J)

        if M == Set:
          break

      p = True
      k = 0

###      print("P[", m, "] =")
###      for i in range(0, 105):
###        print(i, "\t", P[m][i])      

    if M == Set:
      break

  if M == Set:
    print("Vertik Verklebung vollständig in Blöcken dargestellt")
    continue

mm = 0

print("O[", mm, "][0] =", O[mm][0])
print("O[", mm, "][2] =", O[mm][2])

mm = 0

print("P[", mm, "] =")
for i in range(0, 105):
  print(i, "\t", P[mm][i])

##**Visualisierung der Origamis als Pixelmatrix**

import numpy as np

# use Matplotlib
import matplotlib.pyplot as plt

# Normalize all values between 0 and 1 and flatten input Data

print("P = ", P)

arrayP = np.array(P)

arrayP = arrayP.astype('float32') / l

arrayP = arrayP.reshape((len(arrayP), np.prod(arrayP.shape[1:])))

print("\narrayP = \n\n", arrayP, "\n")

# visualize inputs

n = 10  # how many digits we will display
plt.figure(figsize=(20, 4))
for i in range(n):
    
    ax = plt.subplot(2, n, i + 1)
    plt.imshow(arrayP[i].reshape(105, 105))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)

plt.show()

## **Einige Informatione zur Liste P der Pixeldarstellungen**

import numpy as np

print("Informationen über die Liste P der Pixeldarstellungen")

#for i in range(0, 10):
#  print("P[", i, "] =", P[i])

print("\nlen(P) =", len(P))

P_arr = np.array(P)

print("\nP.shape =", P_arr.shape)

# **Anwendung von One-Shot-Learning mit Siamese-Networks auf die Pixeldarstellung der Origamis**

https://towardsdatascience.com/one-shot-learning-with-siamese-networks-using-keras-17f34e75bb3d

https://github.com/hlamba28/One-Shot-Learning-with-Siamese-Networks

https://github.com/hlamba28/One-Shot-Learning-with-Siamese-Networks/blob/master/Siamese%20on%20Omniglot%20Dataset.ipynb

import sys
import numpy as np
import pandas as pd
#from scipy.misc import imread                                                  #!!!!!!!!!!
import pickle
import os
import matplotlib.pyplot as plt
%matplotlib inline

import cv2
import time

import tensorflow as tf
from keras.models import Sequential
from keras.optimizers import Adam
from keras.layers import Conv2D, ZeroPadding2D, Activation, Input, concatenate
from keras.models import Model

from keras.layers.normalization import BatchNormalization
from keras.layers.pooling import MaxPooling2D
from keras.layers.merge import Concatenate
from keras.layers.core import Lambda, Flatten, Dense
from keras.initializers import glorot_uniform

from keras.engine.topology import Layer
from keras.regularizers import l2
from keras import backend as K

from sklearn.utils import shuffle

import numpy.random as rng

## **Erzeugen und Trainieren eines Siamese Networks**

### **Benötigte Funktionen**

def initialize_weights(shape, dtype=None):
    """
        The paper, http://www.cs.utoronto.ca/~gkoch/files/msc-thesis.pdf
        suggests to initialize CNN layer weights with mean as 0.0 and standard deviation of 0.01
    """
    return np.random.normal(loc = 0.0, scale = 1e-2, size = shape)

def initialize_bias(shape, dtype=None):
    """
        The paper, http://www.cs.utoronto.ca/~gkoch/files/msc-thesis.pdf
        suggests to initialize CNN layer bias with mean as 0.5 and standard deviation of 0.01
    """
    return np.random.normal(loc = 0.5, scale = 1e-2, size = shape)

def get_siamese_model(input_shape):
    """
        Model architecture based on the one provided in: http://www.cs.utoronto.ca/~gkoch/files/msc-thesis.pdf
    """
    
    # Define the tensors for the two input images
    left_input = Input(input_shape)
    right_input = Input(input_shape)
    
    # Convolutional Neural Network
    model = Sequential()
    model.add(Conv2D(64, (10,10), activation='relu', input_shape=input_shape,
                   kernel_initializer=initialize_weights, kernel_regularizer=l2(2e-4)))
    model.add(MaxPooling2D())
    model.add(Conv2D(128, (7,7), activation='relu',
                     kernel_initializer=initialize_weights,
                     bias_initializer=initialize_bias, kernel_regularizer=l2(2e-4)))
    model.add(MaxPooling2D())
    model.add(Conv2D(128, (4,4), activation='relu', kernel_initializer=initialize_weights,
                     bias_initializer=initialize_bias, kernel_regularizer=l2(2e-4)))
    model.add(MaxPooling2D())
    model.add(Conv2D(256, (4,4), activation='relu', kernel_initializer=initialize_weights,
                     bias_initializer=initialize_bias, kernel_regularizer=l2(2e-4)))
    model.add(Flatten())
    model.add(Dense(4096, activation='sigmoid',
                   kernel_regularizer=l2(1e-3),
                   kernel_initializer=initialize_weights,bias_initializer=initialize_bias))
    
    # Generate the encodings (feature vectors) for the two images
    encoded_l = model(left_input)
    encoded_r = model(right_input)
    
    # Add a customized layer to compute the absolute difference between the encodings
    L1_layer = Lambda(lambda tensors:K.abs(tensors[0] - tensors[1]))
    L1_distance = L1_layer([encoded_l, encoded_r])
    
    # Add a dense layer with a sigmoid unit to generate the similarity score
    prediction = Dense(1,activation='sigmoid',bias_initializer=initialize_bias)(L1_distance)
    
    # Connect the inputs with the outputs
    siamese_net = Model(inputs=[left_input,right_input],outputs=prediction)
    
    # return the model
    return siamese_net

### **Darstellung der Netzwerk (Model) Architektur**

model = get_siamese_model((105, 105, 1))
model.summary()

### **Kompilieren des Models**

optimizer = Adam(lr = 0.00006)
model.compile(loss="binary_crossentropy",optimizer=optimizer)

### **Weitere Fuktionen**

print("\nP_arr.shape =", P_arr.shape)

P_array = shuffle(P_arr)

def get_batch(batch_size,s="train"):
    """Create batch of n pairs, half same class, half different class"""
    if s == 'train':
        L = 0
        K = (len(P_array) // 3) * 2
    else:
        L = (len(P_array) // 3) * 2
        K = len(P_array)

    n_image, w, h = P_array.shape
    
    # initialize 2 empty arrays for the input image batch
    pairs=[np.zeros((batch_size, h, w,1)) for i in range(2)]
    
    # initialize vector for the targets
    targets=np.zeros((batch_size,))
    
    # make one half of it '1's, so 2nd half of batch has same class
    targets[batch_size//2:] = 1
    for i in range(batch_size):

        image_1 = rng.randint(0, len(P_array))
        pairs[0][i,:,:] = P_array[image_1].reshape(w, h, 1)
        image_2 = rng.randint(0, len(P_array))
#        image_2 = (image_1 + rng.randint(0, len(P_array))) % len(P_array)
        
        # pick images of same class for 1st half, different for 2nd
        if i >= batch_size // 2:
            pairs[1][i,:,:] = P_array[image_1].reshape(w, h, 1) 
        else: 
            # add a random number to the category modulo n classes to ensure 2nd image has a different category
            pairs[1][i,:,:] = P_array[image_2].reshape(w, h, 1)
    
    return pairs, targets

def generate(batch_size, s="train"):
    """a generator for batches, so model.fit_generator can be used. """
    while True:
        pairs, targets = get_batch(batch_size,s)
        yield (pairs, targets)

def make_oneshot_task(N, s="val"):                                              #, language=None):
    """Create pairs of test image, support set for testing N way one-shot learning. """

    if s == 'train':
        L = 0
        K = (len(P_array) // 3) * 2
    else:
        L = (len(P_array) // 3) * 2
        K = len(P_array)

    n_image, w, h = P_array.shape

    examples = rng.randint(L, K, size = (N,))
    true_example = examples[0]

    test_image = np.asarray([P_array[true_example,:,:]] * N).reshape(N, w, h, 1)

    support_set = P_array[examples,:,:]
    support_set[0,:,:] = P_array[true_example]
    support_set = support_set.reshape(N, w, h, 1)

    targets = np.zeros((N,))
    targets[0] = 1

    targets, test_image, support_set = shuffle(targets, test_image, support_set)

    pairs = [test_image,support_set]

    return pairs, targets

def test_oneshot(model, N, k, s = "val", verbose = 0):
    """Test average N way oneshot learning accuracy of a siamese neural net over k one-shot tasks"""
    n_correct = 0
    if verbose:
        print("Evaluating model on {} random {} way one-shot learning tasks ... \n".format(k,N))
    for i in range(k):
        inputs, targets = make_oneshot_task(N,s)
        probs = model.predict(inputs)
        if np.argmax(probs) == np.argmax(targets):
            n_correct+=1
    percent_correct = (100.0 * n_correct / k)
    if verbose:
        print("Got an average of {}% {} way one-shot learning accuracy \n".format(percent_correct,N))
    return percent_correct

### **Hyperparameter**

# Hyper parameters
evaluate_every = 200 # interval for evaluating on one-shot tasks
batch_size = 16                                                                 #32
n_iter = 2000                                                                   #20000 # No. of training iterations
                                                                                #nur ein Beispiel pro Kategorie, vermeidung von Overfitting
N_way = 9 # how many classes for testing one-shot tasks                         #20
n_val = 250 # how many one-shot tasks to validate on
best = -1

### **Trainieren des Modells**

print("Starting training process!")
print("-------------------------------------")
t_start = time.time()
for i in range(1, n_iter+1):
    (inputs,targets) = get_batch(batch_size)
    loss = model.train_on_batch(inputs, targets)
    if i % evaluate_every == 0:
        print("\n ------------- \n")
        print("Time for {0} iterations: {1} mins".format(i, (time.time()-t_start)/60.0))
        print("Train Loss: {0}".format(loss)) 
        val_acc = test_oneshot(model, N_way, n_val, verbose=True)
#        model.save_weights(os.path.join(model_path, 'weights.{}.h5'.format(i)))
        if val_acc >= best:
            print("Current best: {0}, previous best: {1}".format(val_acc, best))
            best = val_acc

## **Vergleichen (der Pixeldarstellungen) von Origamis**

Vergleiche ein Origami mit allen anderen Origamis um möglichst ähnliche zu finden.

print("P_arr.shape =", P_arr.shape)

pairs, targets = get_batch(batch_size)

pairs_arr = np.array(pairs)

print("pairs.shape =", pairs_arr.shape)

print("pairs[0].shape =", pairs_arr[0].shape)
print("pairs[1].shape =", pairs_arr[0].shape)

image_index = -1                                                                #default = -1, Indesy des zu vergleichenden Origamis

def make_comparison(image_index):

  n_image, w, h = P_arr.shape

  if image_index == -1:
#    image_index = 0
    image_index = rng.randint(0, len(P_arr))
#    print("image_index =", image_index) 


    test_image = np.asarray([P_arr[image_index,:,:]])

#    print("test_image =", test_image)

    print("test_image.shape =", test_image.shape)


    test_image_set_list = []
    for i in range(0, len(P_arr)):
      test_image_set_list.append(test_image)

    test_image_set = np.array(test_image_set_list).reshape(len(P_arr), w, h, 1)

    print("test_image_set.shape =", test_image_set.shape)


    test_set = P_arr[:, :, :]
    test_set = test_set.reshape(len(P_arr), w, h, 1)

    print("test_set.shape =", test_set.shape)


    pairs = [test_image_set, test_set]

    pairs_arr = np.array(pairs)

    print("pairs.shape =", pairs_arr.shape)

    print("pairs[0].shape =", pairs_arr[0].shape)
    print("pairs[1].shape =", pairs_arr[0].shape)

    probs = model.predict(pairs)

    print("probs[0] =", probs[0])

    x = rng.randint(0, len(P_arr))
    print("probs[", x, "] =", probs[x])


    sim_set_list = []
    sim_set_list.append(P_arr[image_index])

    for i in range(0, len(P_arr)):
      if probs[i] > 0.5:
        sim_set_list.append(P_arr[i])

    print("len(sim_set_list) =", len(sim_set_list))

    sim_set = np.array(sim_set_list)

    return sim_set


make_comparison(image_index)


### **Darstellung der Ergebnisse**

sim_set = make_comparison(image_index)

import numpy as np

# use Matplotlib
import matplotlib.pyplot as plt

# Normalize all values between 0 and 1 and flatten input Data

arrayP = sim_set

arrayP = arrayP.astype('float32') / l

arrayP = arrayP.reshape((len(arrayP), np.prod(arrayP.shape[1:])))

print("\narrayP = \n\n", arrayP, "\n")

# visualize inputs

n = len(arrayP)  # how many digits we will display
plt.figure(figsize=(20, 4))
for i in range(n):
    
    ax = plt.subplot(2, n, i + 1)
    plt.imshow(arrayP[i].reshape(105, 105))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)

plt.show()
